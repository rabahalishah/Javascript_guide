-------------Synchronous VS Asynchronous

Synchronous simply means that the code will execute line by line in the same order as we have defined in our code.
Asynchronous code executes after the task finishes in the background.
Asynchronous is non blocking
callback functions does NOT automatically make the code Asynchronous

---------------------what is AJAX?
AJAX stands for Asynchronous javascript and XML. AJAX allows us to communicate with the remote web servers in an Asynchronous way. With AJAX calls we can request data dynamically from the web
servers.

The communication between client and web server happen Asynchronously. Like sending HTTP request to GET, POST, PUT, DELETE Data from the web server. This happens with the help of
web API.

----------------What is API
Application Programming Interface: In simple words API is a piece of software which is used by another piece of software in order to communicate or talk to each other.
There are several types of Web APISs such as:
DOM API, Geolocation API, Own Class API, Online API

Online API: Is simply an application running on web servers which receives requests for data and send data back as response. We also call them API / Web API.

We can build our own APIs. This include the backend development. In order to create any web app you can use the 3rd-Party APIs which you can embed in your own
API to complete your application

---------------------XML
and XML is simple a data format which is widely used to transmit data. In Todays AGE nobody use XML data format to transmit data. Since AJAX is we old term but it still use these days. 
Now most of the Web Servers today use JSON (Javascript object notation) data format. It is simply a javascript object converted into string. Which makes it very easy to use once the data is arrived.


---------CORS
Cross-origin resource sharing. Without CORS we cannot share data. It is a browser mechanism which enables controlled access to resources located outside of a given domain.


-------------------JSON. parse()
The JSON. parse() method in JavaScript is used to parse (convert back to) a JSON string which is written in a JSON format and returns a JavaScript object. Parameters: JSON String

------------HOW Web works request and response

The client send Http request to the web server and then the web server send the data as response. This whole process is called Request response model or Client-server- Architecture.	
The URL consist of Protocol, Domain name and resourses
Protocol://domain/resources

Domain name is actually NOT the actual address of the server. We convert the domain name into server address by DNS lookup. (DNS stands for Domain name server) DNS is a specail type of server 
with matches our domain name with the real IP address of the server. Once the domain name and IP address is matched. An TCP/IP Socket connection is established between client and web server. They decide how the data will travel accros the web. Its not good Idea to send the whole bunch of data to web server as a request and get the reponse in the same way. TCP/IP organize the way the data will transfer.
TCP = Transmission control protocol and IP= internet protocol. Protocol is simply set of rules with which two parties are allowed to communicate.

HTTP requests contains:

Start-line: HTTP method + req target + HTTP version e.g GET/ rest/v2/HTTP/1.1
HTTP request headers: it contains some info like host, language and browser info etc.
Body: The data we need

HTTP response contains 

Start-line: HTTP version + status code + status message e.g HTTP/1.1 200 OK
HTTP response headers: date, content-type, transfer-encoding
Body: The data we need (JSON OR XML)



The difference between HTTP and HTTPs is that HTTPs is encrypted with SSL and TLS. SSL (Secure Sockets Layer) encryption, and its more modern and secure replacement, TLS (Transport Layer Security) encryption, protect data sent over the internet or a computer network.



---------------Promise and fetch
const request = fetch('https://www.webapi.com');
console.log(request) // promise obj

---------what is PROMISE
Its an ES6 feature
promise is simply an object that is used a placeholder for the future results of an asynchronous operation. OR informally its a container for future value. By future value we simply mean an AJAX call. 

Instead of nesting call back functions we can make a chain of promises for a sequence of asynchronous operations

-----------Promise LIFECYCLE
Promises work with asynchronous JS so they change their state with time. 

initial status: pending (during this state the promise remains pending and async task is working behind the scene)
Final status: settled (once the async task finishes then the promise will either get fulfilled or rejected)

We can also build promise and consume promise. But in most of the cases we consume promises. We consume the promise by using then() method in which pass a callback function. 
The argument which this callback fucntion takes is the value which will return in the future once the async task has successfuly completed and that return value is called response.


const getCountryData = function (country) {
  fetch(`https://restcountries.com/v3.1/name/${country}`)
    .then(response => response.json())
    .then(data => console.log(data))
    .catch(err => console.err(err))
};

getCountryData('Pakistan');

here the response is come with JSON method which is also an async function which will also return a promise so we need to handle that promise too. So in order to handle that promise we call another callback function. Catch() method is used to handle the error.
You must remember that catch itself returns a promise.

-----------.finally()
This method will run either the promise is fulfilled or rejected



-------------Throw custom errors
const getCountryData = function (country) {
  fetch(`https://restcountries.com/v3.1/name/${country}`)
    .then(response => response.json())
    .then(response => if (!reponse.ok) throw new Error (`Country not found ${response.message})`);
	return response.json()
};


------------Asynchronous Event Loop
If JS is a single thread language then how it is able to run multiple task at a time? How can Asynchronous code can be executed in a non blocking way?
The answer is that the asynchronous code runs in web API environment instead of call stack where it could block the code. Once the task is completed on the backend the callback function lies in callback queue its simply a queue like a to do list which has to be done in future. For example you set a timer of 5 sec. After the 5 sec the function will move from web API to callback queue. If theres no anyother callback function waiting for execution then our timer code will be executed this means that our 5 sec timer doesnt mean that this function will run right after 5 sec.
No we are not sure. But we are sure that this function will not run before 5 sec. So this all depends on the state of callback queue.
IMP point to note that callback queue also contains DOM events. Despite having the fact that the DOM events are not Async but still they use callback queue for their execution.

This means JS have no sense of time. If theres any async code then this code will not execute in the browser engine it will execute in the run time who manages all the async behaviour and its event loop who decide which callback will be executed next.

There is another queue called microtasks queue. This queue is for promises cause promises donot go to callback queue instead they go to microtasks queue.

Microtask queue have greater pirority than callback queue.This means eventloop will first check microtasks queue then callback queues
Never forget that the callbacks of promises always execute first due to micro tasks queue.

---------------------Trick guess the output of Asynchronous code
The trick is that the synchronous code will always be executed first and will be executed line by line. But the Async code will not execute simply as we thought. In case of promises the promises will be executed frist after that the other callback functions will be executed included the DOM event.


console.log('Test Start');
setTimeout(()=> console.log('0 sec timer'), 0);
promise.resolve('Resolved Promise 1').then(res => console.log(res));

promise.resolve('Resolved Promise 1').then(res => {
for (let i=0; i<1000000; i++) {}
console.log(res)});
console.log('Test End');

// Test Start
// Test End
// Resolved Promise 1
// Resolved Promise 2
// 0 sec timer

------------------Exp2
console.log('Test Start');
setTimeout(()=> console.log('0 sec timer'), 0);
function myfunc() {Promise.resolve('Resolved Promise 1').then(res => console.log(res))
setTimeout(()=> console.log('0 sec timer 2'), 0)}

function myfunc2() {Promise.resolve('Resolved Promise 2').then(res => {
for (let i=0; i<10000000000; i++) {}
console.log(res)})};
myfunc();
myfunc2();
console.log('Test End');

// Test Start
// Test End
// Resolved Promise 1
// Resolved Promise 2
// 0 sec timer
// 0 sec timer 2


Explanation: As we can see that the promise 2 contains a large time taking task but no matter the promises will be executed first than anyother callback functions. Therefore, we can see the time given to the settimer function has no value over promises. Ideally 0 sec timer should be log first as it takes only 0 sec to execute but this was not the case as Async code runs on pirority principle which is decide by the event loop. Again The trick is that the synchronous code will always be executed first and will be executed line by line. But the Async code will not execute simply as we thought. In case of promises the promises will be executed frist after that the other callback functions will be executed included the DOM event.


----------------Building our own promises

Promises are special kind of JS objects
we can create promises as shown below:

const promise1 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('foo');
  }, 300);
});

promise1.then((res) => {
  console.log(res);
  // Expected output: "foo"
});

console.log(promise1);
// Expected output: [object Promise]

Its important to note that in case of successful event the value of response would be the same value return the function on which this method is called.

Resolve and reject methods are used to immediately resolve or reject the promise. These two are also the arguments of the constructor function which create a new promise as mentioned code above.
In reject function we mostly create new error 

----------Promisify
In JavaScript, promisify is a common technique used to convert asynchronous functions that follow the traditional callback pattern into functions that return promises. 
for example:


const getPosition = function () {
  return new Promise(function (resolve, rejected) {
    navigator.geolocation.getCurrentPosition(
      position => resolve(position),
      err => console.error(err)
    );
  });
};

---------------Creating async function--------------
const whereAmI = async function(country) {
  const res = await fetch(`https://restcountries.com/v3.1/name/${country}`);
  console.log(res);
}

whereAmI('pakistan')
console.log('First')

async function is a function which executed async behind the scenes until its code is executing at back end.

await keyword is just another way of consuming promises. In actual old school way we simply call an async function which returns a promise and we have to deal with that promise by using then method. Moreover If we apply .json() method on the response we again get a promise and again we have to use then() method to deal with that promise. 

In the modern way we use async await to handle the promise we use await keyword and stores its value in a variable that value will be count as the response of that promise.

Async await is nothing just a different syntax for promises and its handeling. This syntax is literally a blessing this syntax prevent the formation of callback hell. Due to which the code is easy to debug, reuse and maintainable.

---------------Handling Errors with Try Catch--------

try {

} catch (err) {
	console.error(`${err.message}`)
}


----------Getting value from async function

since we all know that async function do not run immediately. But what if we pass function as a value and then call it?
in this way you will get a promise (as we all know async function returns a promise). but if we pass that function as a value and then execute it. It will return a promise pending in console.

console.log("start")
const cool = whereAmI()
cool()
console.log("end")

//start
// promise <pending>
// end

Here above we have passed function as a value and then executed it. Remember is an async function


Now simply direct calling the async function

console.log("start")
whereAmI().then(res => console.log(res); 
console.log("end")

// start
// end
// response

NOTE: never run an async function without try and catch block

------------Runnig async functions in parallel
you can several async functions by async await method but if the functions are dependent then the rejection of each promise will to the rejection of all promise. Therefore we often say promises are shortcicrcuits.

promise.all() function get shortcircuit on faliure of any promise.
whereas promise.allSettled() do not get short circuit on rejection of an event

promise.any() this function returns a first true promises only.  

--------await keyword only works on async function----------------
this statement is true. Cause await keyword pause the execution. And this is only possible for async code/function. Remember our fetch function is built in async function.

Examples:

function myfunc(){
  for(i=0; i<100; i++){
    console.log(i);
  }
}

async function main() {
  console.log('innner above');
  await myfunc(); // here await is useless cause myfunc is not an async function
  console.log('innner below');
}

console.log('outer 2');

main();
function myfunc2(){
  console.log('function 2')
}

myfunc2();

console.log('outer 3')

Explanation:

In JavaScript, asynchronous functions are executed differently from synchronous functions. When you call an asynchronous function, it starts executing, but it doesn't block the execution of the rest of your code. Instead, it allows the code following the asynchronous function call to continue running while the asynchronous function completes its tasks.

In your code, the function `myfunc()` is an asynchronous function, and it contains a loop that logs the values of `i`. However, since there is no asynchronous behavior within `myfunc()`, it runs synchronously and logs the values from 0 to 99.

The `main()` function is also an asynchronous function. When you call `main()`, it starts executing, and the first line inside `main()` is to log "inner above" to the console. Then, the `await myfunc()` line is encountered.

The `await` keyword pauses the execution of the `main()` function until the promise returned by `myfunc()` is resolved. In this case, since `myfunc()` doesn't return a promise explicitly, the JavaScript engine wraps its return value (which is `undefined`) into a resolved promise. This allows the execution of `main()` to continue.

While `main()` is waiting for the completion of `myfunc()`, the code outside the `main()` function continues to execute. That's why you see "outer 2" being logged to the console.

Once the loop in `myfunc()` completes logging the numbers, the execution returns to the `await myfunc()` line inside `main()`, and it proceeds to log "inner below" to the console.

After that, the code continues to execute outside the `main()` function. Hence, you see "outer 3" being logged to the console.

To summarize, the output order is as follows:
1. outer 1
2. outer 2
3. inner above
4. 0
5. 1
6. 2
...
97. 97
98. 98
99. 99
100. inner below
101. function 2
102. outer 3

Note that the `console.log()` statement inside `myfunc2()` is executed immediately when called, so "function 2" is logged before "outer 3".

------------------------------ 
Example 2:

async function myfunc(){
  const data = await fetch('https://restcountries.com/v3.1/name/portugal')
  console.log(data)
  for(i=0; i<100; i++){
    console.log(i); 

  }
}

async function main() {
  console.log('innner above');
  await myfunc();
  console.log('innner below');
}

console.log('outer 2');

main();
function myfunc2(){
  console.log('function 2')
}

myfunc2();

console.log('outer 3')
"





 